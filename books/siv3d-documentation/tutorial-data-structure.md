---
title: "チュートリアル 06 | データ構造"
free: true
---

# 6. データ構造
この章では、Siv3D でゲームやアプリケーションを実装するうえで重要な、動的配列や二次元配列、ハッシュテーブルなど基本的なデータ構造のクラスを学びます。

## 6.1 
Siv3D で動的配列を扱うときは `Array<Type>` クラステンプレートを使います。`std::vector` よりも多くの便利なメンバ関数を提供し、Siv3D のクラスや関数とも連係しやすいため、優れた実行時性能と、コードの短縮につながります。`std::vector` と同様に格納されている要素のメモリの連続性が保証されています。

### 6.1.1 要素の追加

```cpp

```


### 6.1.2

```cpp

```


### 6.1.3

```cpp

```


### 6.1.4

```cpp

```


### 6.1.5

```cpp

```


### 6.1.6

```cpp

```


### 6.1.7

```cpp

```


### 6.1.8

```cpp

```


## 6.2 二次元配列
方眼紙のように区切ったマップの情報やスプレッドシートのように、二次元配列が必要な情報を扱うときには `Grid<Type>` クラステンプレートを使います。`Grid` を使うことで、特に、動的な二次元配列を扱う際に、面倒なコードを書く必要がなくなります。`Grid` は内部では 1 つの `Array` ですべての要素を連続的に保持しています。インデックスとして `[y][x]` の他に `Point` を使うことができます。

### 6.2.1 

```cpp

```


### 6.2.2

```cpp

```


### 6.2.3

```cpp

```


## 6.3 ハッシュテーブル

```cpp

```


## 6.4 ハッシュセット

```cpp

```


## 6.5 オプショナル型
`Optioanl<Type>` 型を使うと、任意の型 `Type` が「無効値」も保持できるようになります。サイズが 0 か 1 のいずれかである `Array<Type>` と考えるとわかりやすいです。C++ 標準では `std::optional<Type>` に相当します。

オプショナル型の値 `opt` が有効値を保持しているかは `if (opt)` や `if (opt.has_value())` で調べられます。`Type` 型の値を取り出すには `*opt` または `opt.value()` を使います。後者は有効値を保持しているかチェックし、保持していなかった場合には `std::bad_optional_access` 例外を投げます。`Type` 型のメンバにアクセスするには `opt->` を使います。`opt.value_or(x)` は、有効値を保持している場合はその値を、保持していない場合は代わりに `x` を返します。

無効値を表す `none` およびそれと同値の `unspecified` という定数があります。

```cpp

```


## 6.6 これ以外のデータ構造
Siv3D では、配列の要素数がコンパイル時に決まっていて実行中に変更されない静的配列は `std::array` を使います。また、動的配列は `std::deque` や `std::list` を使うよりも、メモリの連続性がある `Array` のほうが実行時性能に優れるケースが多くあります。特に要素数が数万規模まで大きくならない動的配列については `Array` を優先して使うことを推奨します。
